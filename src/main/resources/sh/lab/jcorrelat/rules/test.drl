/*
 * Copyright 2011 Dustin Frisch<fooker@lab.sh>
 * 
 * This file is part of senchineru.
 * 
 * senchineru is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * senchineru is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with senchineru.  If not, see <http://www.gnu.org/licenses/>.
 */
package sh.lab.jcorrelat.rules;

import sh.lab.jcorrelat.Message;
import static sh.lab.jcorrelat.MessageFactory.messageFactory

import java.util.regex.Matcher
import java.util.regex.Pattern

import java.util.concurrent.CopyOnWriteArrayList;



declare Message
    @role(event)
    @timestamp(time)
end


rule "SSH login success"
no-loop
when
    message : Message( message matches "Accepted password for [^\\s]* from [^\\s]* port [^\\s]* ssh2" )
then
    Matcher matcher = Pattern.compile("Accepted password for ([^\\s]*) from ([^\\s]*) port ([^\\s]*) ssh2").matcher(message.getMessage());

    if (matcher.find()) {
        message.addTag("ssh");
        message.addTag("login success");
        message.addStructure("user", matcher.group(1));
        message.addStructure("host", matcher.group(2));
        message.addStructure("port", Integer.parseInt(matcher.group(3)));
        
        update(message);
    }
end


rule "SSH login failed"
no-loop
when
    message : Message( message matches "Failed password for [^\\s]* from [^\\s]* port [^\\s]* ssh2" )
then
    Matcher matcher = Pattern.compile("Failed password for ([^\\s]*) from ([^\\s]*) port ([^\\s]*) ssh2").matcher(message.getMessage());
    
    if (matcher.find()) {
        message.addTag("ssh");
        message.addTag("login failed");
        message.addStructure("user", matcher.group(1));
        message.addStructure("host", matcher.group(2));
        message.addStructure("port", Integer.parseInt(matcher.group(3)));
        
        update(message);
    }
end


rule "SSH bruteforce attempt"
no-loop
when
    failed : CopyOnWriteArrayList( size >= 8 ) from collect(
        Message( "ssh" memberOf tags,
                 "login failed" memberOf tags
        ) over window:time( 20m )
    )
then
    Message last = (Message) failed.get(failed.size() - 1);

    insert(messageFactory()
        .setTime(last.getTime())
        .setHost(last.getHost())
        .setSeverity(Message.Severity.EMERGENCY)
        .setFacility(Message.Facility.SECURITY)
        .setProgram(last.getProgram())
        .setMessage(String.format("Bruteforce attack for %s from %s", last.getStructure("user"), last.getStructure("host")))
        .addTag("ssh")
        .addTag("bruteforce")
        .addStructure("user", last.getStructure("user"))
        .addStructure("host", last.getStructure("host"))
        .message());
    
    for (Object f : failed) {
        retract(f);
    }
end


rule "Successfull SSH bruteforce"
no-loop
when
    attempt : Message( "ssh" memberOf tags,
                       "bruteforce" memberOf tags,
                       "success" not memberOf tags )
    success : Message( "ssh" memberOf tags,
                       "login success" memberOf tags,
                       this finishes[ 10m ] attempt )
then
    attempt.addTag("success");
    attempt.setSeverity(Message.Severity.EMERGENCY);
    attempt.setFacility(Message.Facility.SECURITY);
    attempt.setMessage(attempt.getMessage() + " [success]");

    update(attempt);
end
